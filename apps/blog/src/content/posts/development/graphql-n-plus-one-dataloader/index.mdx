---
title: 'GraphQLì€ N+1 ë¬¸ì œë¥¼ ì–´ë–»ê²Œ í•´ê²°í–ˆì„ê¹Œ? (w/ dataloader)'
description: 'GraphQLì—ì„œ N+1ë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ ì‚¬ìš©ëœ dataloaderì— ëŒ€í•´ ì•Œì•„ë´…ë‹ˆë‹¤.'
date: '2025-03-02'
thumbnail: './images/graphql-n-plus-one-dataloader-thumbnail.png'
thumbnail_alt: 'GraphQL N+1 dataloader Thumbnail'
category: 'development'
---

<Callout>
  ğŸ’¡ GraphQLì—ì„œ N+1ë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ ì‚¬ìš©ëœ dataloaderì— ëŒ€í•´ ì•Œì•„ë´…ë‹ˆë‹¤. í”¼ë“œë°±ì€ ì–¸ì œë‚˜
  í™˜ì˜ì…ë‹ˆë‹¤:)
</Callout>

## GraphQLì—ì„œì˜ N+1 ë¬¸ì œ ì•Œì•„ë³´ê¸°

### N+1 ë¬¸ì œë€?

N+1ì€ ê´€ê³„í˜• ë°ì´í„°ë¥¼ ì¡°íšŒí•  ë•Œ ë°œìƒí•  ìˆ˜ ìˆëŠ” ëŒ€í‘œì ì¸ ì„±ëŠ¥ ì´ìŠˆì´ë‹¤.

ì´ë¦„ì—ì„œ ì•Œ ìˆ˜ ìˆë“¯ì´ í•˜ë‚˜ì˜ ì¿¼ë¦¬ ì´í›„ Nê°œì˜ ì¶”ê°€ ì¿¼ë¦¬ê°€ ë°œìƒí•˜ëŠ” íŒ¨í„´ì„ ì˜ë¯¸í•˜ëŠ”ë°..

<br />

ì½”ë“œë¡œ ë³´ëŠ”ê²Œ ì´í•´ê°€ ê°€ì¥ ë¹ ë¥¼ ê²ƒ ê°™ë‹¤..! ğŸ˜‚

ê°„ë‹¨í•œ í™˜ê²½ì„ êµ¬ì„±í•´ì„œ ì§ì ‘ í™•ì¸í•´ë³´ì. ([ê´€ë ¨ ì½”ë“œ](https://github.com/jgjgill/jgjgill-weapons/tree/main/apps/graphql-playground))

<br />

ë‹¤ìŒ ë¼ì´ë¸ŒëŸ¬ë¦¬ë“¤ì„ ì„¤ì¹˜í•œë‹¤.

<br />

**package.json**

```bash
pnpm i @apollo/server better-sqlite3 graphql graphql-tag
```

<br />

**index.js**

```js
import { ApolloServer } from '@apollo/server'
import { startStandaloneServer } from '@apollo/server/standalone'
import gql from 'graphql-tag'
import db from './database.js'

const typeDefs = gql`
  type Post {
    id: ID!
    title: String!
    content: String!
    comments: [Comment!]!
  }

  type Comment {
    id: ID!
    content: String!
    post: Post!
  }

  type Query {
    posts: [Post!]!
    post(id: ID!): Post
  }
`

const resolvers = {
  Query: {
    posts: () => {
      console.log('Fetching all posts')

      return db.prepare('SELECT * FROM posts').all()
    },
  },
  Post: {
    comments: (post) => {
      console.log(`Fetching comments for post ${post.id}`)

      return db.prepare('SELECT * FROM comments WHERE post_id = ?').all(post.id)
    },
  },
}

const server = new ApolloServer({
  typeDefs,
  resolvers,
})

const { url } = await startStandaloneServer(server, {
  listen: { port: 4001 },
})

console.log(`ğŸš€  Server ready at: ${url}`)
```

<br />

**database.js**

```js
import { existsSync } from 'node:fs'
import Database from 'better-sqlite3'

const dbPath = 'blog.db'
const db = new Database(dbPath)

if (!existsSync(dbPath)) {
  db.exec(`
    DROP TABLE IF EXISTS posts;
    DROP TABLE IF EXISTS comments;
    
    CREATE TABLE posts (
      id INTEGER PRIMARY KEY,
      title TEXT,
      content TEXT
    );
    
    CREATE TABLE comments (
      id INTEGER PRIMARY KEY,
      post_id INTEGER,
      content TEXT,
      FOREIGN KEY (post_id) REFERENCES posts (id)
    );
    
    -- ìƒ˜í”Œ ë°ì´í„° ì‚½ì…
    INSERT INTO posts (title, content) VALUES 
      ('ì²« ë²ˆì§¸ ê¸€', 'ì•ˆë…•í•˜ì„¸ìš”'),
      ('ë‘ ë²ˆì§¸ ê¸€', 'ë°˜ê°‘ìŠµë‹ˆë‹¤'),
      ('ì„¸ ë²ˆì§¸ ê¸€', 'ë‚ ì”¨ê°€ ì¢‹ë„¤ìš”');
      
    INSERT INTO comments (post_id, content) VALUES 
      (1, 'ì¢‹ì€ ê¸€ì´ì—ìš”!'),
      (1, 'ê°ì‚¬í•©ë‹ˆë‹¤'),
      (2, 'ë™ì˜í•©ë‹ˆë‹¤'),
      (3, 'ë©‹ì§„ ê¸€ì´ë„¤ìš”'),
      (3, 'ì˜ ë³´ê³  ê°‘ë‹ˆë‹¤');
  `)
}

export default db
```

<br />

**Operation**

`posts` ë‚´ `comments`ë¥¼ ë¶ˆëŸ¬ì˜¨ë‹¤.

```GraphQL
query {
  posts {
    id
    title
    comments {
      id
      content
    }
  }
}
```

<br />

<Image
  src="https://raw.githubusercontent.com/jgjgill/blog/main/contents/development/graphql-n-plus-one-dataloader/images/operation.png"
  alt="GrpahQL - Operation"
/>

<br />

**ê²°ê³¼**

4ë²ˆì˜ í˜¸ì¶œ(N+1)ì´ ë°œìƒí•˜ëŠ” ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤.

<br />

<Image
  src="https://raw.githubusercontent.com/jgjgill/blog/main/contents/development/graphql-n-plus-one-dataloader/images/n-plus-one-result.png"
  alt="N+1 ê²°ê³¼"
/>

## dataloader

ì´ëŸ¬í•œ N+1 ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ `GraphQL`ì€ `dataloader`ë¼ëŠ” ë„êµ¬ë¥¼ í™œìš©í•œë‹¤.

<br />

`dataloader`ë¥¼ ì„¤ì¹˜í•œë‹¤.

```bash
pnpm i dataloader
```

<br />

**index-dataloader.js**

```js
import { ApolloServer } from '@apollo/server'
import { startStandaloneServer } from '@apollo/server/standalone'
import DataLoader from 'dataloader'
import gql from 'graphql-tag'
import db from './database.js'

const typeDefs = gql`
  type Post {
    id: ID!
    title: String!
    content: String!
    comments: [Comment!]!
  }

  type Comment {
    id: ID!
    content: String!
    post: Post!
  }

  type Query {
    posts: [Post!]!
    post(id: ID!): Post
  }
`

// Commentsë¥¼ ë°°ì¹˜ë¡œ ë¡œë”©í•˜ëŠ” DataLoader ìƒì„±
function createCommentsLoader() {
  return new DataLoader(async (postIds) => {
    console.log(`Batch loading comments for posts: ${postIds.join(', ')}`)

    const comments = db
      .prepare(
        `SELECT * FROM comments WHERE post_id IN (${postIds.map(() => '?').join(',')})`,
      )
      .all(...postIds)

    // postIdë³„ë¡œ comments ê·¸ë£¹í™”í•˜ì—¬ ë°˜í™˜
    return postIds.map((postId) =>
      comments.filter((comment) => comment.post_id === Number.parseInt(postId)),
    )
  })
}

const resolvers = {
  Query: {
    posts: () => {
      console.log('Fetching all posts')
      return db.prepare('SELECT * FROM posts').all()
    },
  },
  Post: {
    comments: (post, _, context) => {
      return context.commentsLoader.load(post.id)
    },
  },
}

const server = new ApolloServer({ typeDefs, resolvers })

const { url } = await startStandaloneServer(server, {
  listen: { port: 4000 },
  context: () => ({
    commentsLoader: createCommentsLoader(),
  }),
})

console.log(`ğŸš€ Server ready at: ${url}`)
```

<br />

**Operation**

ë™ì¼í•œ ì¿¼ë¦¬ë¥¼ í˜¸ì¶œí•œë‹¤.

<br />

**ê²°ê³¼**

ì´ì „ê³¼ ë‹¬ë¦¬ 2ë²ˆì˜ í˜¸ì¶œë§Œ ë°œìƒí•œë‹¤.

<br />

<Image
  src="https://raw.githubusercontent.com/jgjgill/blog/main/contents/development/graphql-n-plus-one-dataloader/images/dataloader-result.png"
  alt="dataloader ê²°ê³¼"
/>

ì–´ë–»ê²Œ ì´ëŸ¬í•œ ë™ì‘ì´ ê°€ëŠ¥í•´ì§„ê±¸ê¹Œ?

### ë‚´ë¶€ ì½”ë“œ ë¶„ì„

`dataloder`ëŠ” ì•½ 500ì¤„ë¡œ ì´ë£¨ì–´ì§„ ë¼ì´ë¸ŒëŸ¬ë¦¬ë‹¤.

<br />

ë‚´ë¶€ ì½”ë“œë¥¼ ì‚´í´ë³´ë©´ ë°°ì¹­ê³¼ ìºì‹± ê¸°ëŠ¥ì´ ì ìš©ë˜ëŠ”ë°,

ì´ë²ˆ ê¸€ì—ì„œëŠ” ìºì‹±ê³¼ ê´€ë ¨ëœ ë‚´ìš©ì€ ë‹¤ë£¨ì§€ ì•Šê³  ë°°ì¹­ì— ëŒ€í•´ì„œë§Œ ì•Œì•„ë³´ê³ ì í•œë‹¤.

### batching

ì—¬ëŸ¬ ê°œë³„ ë°ì´í„° ìš”ì²­ì„ ë‹¨ì¼ ìš”ì²­ìœ¼ë¡œ ëª¨ì•„ì„œ ì²˜ë¦¬í•œë‹¤.

ì´ë¥¼ í†µí•´ ë„¤íŠ¸ì›Œí¬ ì™•ë³µì„ ì¤„ì´ê³  ì„±ëŠ¥ì„ ê°œì„ ì‹œí‚¤ê³ ì í•œë‹¤.

<br />

í¬ê²Œ ë‹¤ìŒ ì½”ë“œë“¤ì„ í•µì‹¬ìœ¼ë¡œ ì¡ê³  ì‚´í´ë³¼ ê²ƒì´ë‹¤.

ì„ì˜ë¡œ ìƒëµí•œ ë¶€ë¶„ë“¤ì´ ë§ê¸°ì— ì°¸ê³ í•˜ì‹œê¸¸..ğŸ˜‡ ([ì›ë³¸ ì½”ë“œ](https://github.com/graphql/dataloader/blob/main/src/index.js))

#### ì£¼ìš” íƒ€ì… ì •ì˜

```ts
// ë°°ì¹˜ ë¡œë”© í•¨ìˆ˜ íƒ€ì… - í‚¤ ë°°ì—´ì„ ë°›ì•„ Promise ë°°ì—´ ë°˜í™˜
export type BatchLoadFn<K, V> = (keys: Array<K>) => Promise<Array<V | Error>>

// ë°°ì¹˜ ê´€ë ¨ ì˜µì…˜
export type Options<K, V, C = K> = {
  batch?: boolean // ë°°ì¹­ í™œì„±í™” ì—¬ë¶€
  maxBatchSize?: number // ìµœëŒ€ ë°°ì¹˜ í¬ê¸°
  batchScheduleFn?: (callback: () => void) => void // ë°°ì¹˜ ì‹¤í–‰ ìŠ¤ì¼€ì¤„ëŸ¬
  // ê¸°íƒ€ ìºì‹± ê´€ë ¨ ì˜µì…˜ë“¤...
}

// ë°°ì¹˜ ìƒíƒœ ì¶”ì  êµ¬ì¡°
type Batch<K, V> = {
  hasDispatched: boolean // ì²˜ë¦¬ ìƒíƒœ
  keys: Array<K> // ìˆ˜ì§‘ëœ í‚¤ë“¤
  callbacks: Array<{
    // ê° í‚¤ë³„ ì½œë°±
    resolve: (value: V) => void
    reject: (error: Error) => void
  }>
  cacheHits?: Array<() => void> // ìºì‹œ ë™ì‘ ì½œë°±
}
```

<br />

`BatchLoadFn` íƒ€ì…ì€ `dataloader`ì˜ í•µì‹¬ í•¨ìˆ˜ íƒ€ì…ì´ë‹¤.

ì—¬ëŸ¬ ê°œì˜ í‚¤ë¥¼ í•œ ë²ˆì— ì²˜ë¦¬í•˜ê³ ì ì‚¬ìš©ëœë‹¤.

<br />

ì˜ˆì œì—ì„œëŠ” `createCommentsLoader` ë‚´ `DataLoader`ë¡œ ë„˜ê¸´ í•¨ìˆ˜ ë¶€ë¶„ì´ë‹¤.

<br />

**ì˜ˆì‹œ ì½”ë“œ**

```ts
function createCommentsLoader() {
  return new DataLoader(async (postIds) => {
    console.log(`Batch loading comments for posts: ${postIds.join(', ')}`)

    const comments = db
      .prepare(
        `SELECT * FROM comments WHERE post_id IN (${postIds.map(() => '?').join(',')})`,
      )
      .all(...postIds)

    // postIdë³„ë¡œ comments ê·¸ë£¹í™”í•˜ì—¬ ë°˜í™˜
    return postIds.map((postId) =>
      comments.filter((comment) => comment.post_id === Number.parseInt(postId)),
    )
  })
}
```

<br />

`Batch` íƒ€ì…ì—ì„œëŠ” í˜„ì¬ ì§„í–‰ ì¤‘ì¸ ë°°ì¹˜ì˜ ìƒíƒœ êµ¬ì¡°ë¥¼ í‘œí˜„í•œë‹¤.

- `hasDispatched`: ì´ ë°°ì¹˜ê°€ ì´ë¯¸ ì²˜ë¦¬ëëŠ”ì§€ ì—¬ë¶€ë¥¼ í‘œì‹œ
- `keys`: ì´ ë°°ì¹˜ì— ìˆ˜ì§‘ëœ ëª¨ë“  í‚¤ì˜ ë°°ì—´
- `callbacks`: ê° í‚¤ì— ëŒ€ì‘í•˜ëŠ” ë¹„ë™ê¸° í•¨ìˆ˜ ë°°ì—´

<br />

#### DataLoader í´ë˜ìŠ¤

```ts
class DataLoader<K, V, C = K> {
  constructor(batchLoadFn: BatchLoadFn<K, V>, options?: Options<K, V, C>) {
    this._batchLoadFn = batchLoadFn;
    this._maxBatchSize = getValidMaxBatchSize(options);
    this._batchScheduleFn = getValidBatchScheduleFn(options);
    this._batch = null;
    // ê¸°íƒ€ ì´ˆê¸°í™”...
  }

  _batchLoadFn: BatchLoadFn<K, V>;        // ì‚¬ìš©ì²˜ì— ì œê³µë˜ëŠ” ë°°ì¹˜ ë¡œë“œ í•¨ìˆ˜
  _maxBatchSize: number;                  // ìµœëŒ€ ë°°ì¹˜ í¬ê¸°
  _batchScheduleFn: (() => void) => void; // ë°°ì¹˜ ìŠ¤ì¼€ì¤„ë§ í•¨ìˆ˜
  _batch: Batch<K, V> | null;             // í˜„ì¬ í™œì„± ë°°ì¹˜
  // ê¸°íƒ€ í•„ë“œë“¤...

  load(key: K): Promise<V> {
    if (key === null || key === undefined) {
      throw new TypeError(
        'The loader.load() function must be called with a value, ' +
          `but got: ${String(key)}.`,
      );
    }

    const batch = getCurrentBatch(this); // í˜„ì¬ ë°°ì¹˜ ê°€ì ¸ì˜¤ê¸°

    // ìºì‹œ ì²´í¬ ì½”ë“œ ìƒëµ...

    batch.keys.push(key); // ë°°ì¹˜ì— í‚¤ ì¶”ê°€
    const promise = new Promise((resolve, reject) => {
      batch.callbacks.push({ resolve, reject });
    });

    // ìºì‹œ ì €ì¥ ì½”ë“œ ìƒëµ...

    return promise;
  }
}
```

<br />

`DataLoader` í´ë˜ìŠ¤ë¥¼ í†µí•´ ë°°ì¹˜ ë¡œë”© ê¸°ëŠ¥ì˜ ì¸í„°í˜ì´ìŠ¤ë¥¼ íŒŒì•…í•  ìˆ˜ ìˆë‹¤.

<br />

`_batchScheduleFn`ëŠ” ë°°ì¹˜ ì²˜ë¦¬ ì‹œì ì„ ê²°ì •í•˜ëŠ” í•¨ìˆ˜ì´ë‹¤.

ì´ í•¨ìˆ˜ë¥¼ í†µí•´ ì–¸ì œ ë°°ì¹˜ë¥¼ ì‹¤í–‰í• ì§€ ì œì–´í•œë‹¤.

ë°‘ì— ì‚´í´ë³´ê² ì§€ë§Œ í•´ë‹¹ í•¨ìˆ˜ì—ëŠ” `enqueuePostPromiseJob` í•¨ìˆ˜ê°€ ì‚¬ìš©ëœë‹¤.

<br />

`load` ë©”ì„œë“œì—ì„œëŠ” í•˜ë‚˜ì˜ í‚¤ì— ëŒ€í•œ ë°ì´í„° ë¡œë“œë¥¼ ìš”ì²­í•œë‹¤.

ë‚´ë¶€ì ìœ¼ë¡œ `getCurrentBatch` í•¨ìˆ˜ë¥¼ í†µí•´ í˜„ì¬ í™œì„±í™”ëœ ë°°ì¹˜ë¥¼ ê°€ì ¸ì˜¨ë‹¤.

ê°€ì ¸ì˜¨ ë°°ì¹˜ì—ì„œ `keys`, `callbacks` ë°°ì—´ì— í‚¤ì™€ í•¨ìˆ˜ë¥¼ ì¶”ê°€í•œë‹¤.

<br />

- ì²˜ìŒ `load` í˜¸ì¶œ ì‹œ ìƒˆ ë°°ì¹˜ ìƒì„±
- ê°™ì€ ì´ë²¤íŠ¸ ë£¨í”„ `tick` ë‚´ í›„ì† `load` í˜¸ì¶œì€ ë™ì¼ ë°°ì¹˜ì— ëˆ„ì 
- ë°°ì¹˜ê°€ ì´ë¯¸ ì²˜ë¦¬ ì¤‘ì´ê±°ë‚˜ ìµœëŒ€ í¬ê¸°ì— ë„ë‹¬í•˜ë©´ ìƒˆ ë°°ì¹˜ ìƒì„±

<br />

#### ë°°ì¹˜ ê´€ë¦¬ í•µì‹¬ í•¨ìˆ˜ë“¤

```ts
// í˜„ì¬ ë°°ì¹˜ ê°€ì ¸ì˜¤ê¸° ë˜ëŠ” ìƒˆ ë°°ì¹˜ ìƒì„±
function getCurrentBatch<K, V>(loader: DataLoader<K, V, any>): Batch<K, V> {
  const existingBatch = loader._batch

  // ì¬ì‚¬ìš© ê°€ëŠ¥í•œ ë°°ì¹˜ê°€ ìˆìœ¼ë©´ ì‚¬ìš©
  if (
    existingBatch !== null &&
    !existingBatch.hasDispatched &&
    existingBatch.keys.length < loader._maxBatchSize
  ) {
    return existingBatch
  }

  // ìƒˆ ë°°ì¹˜ ìƒì„±
  const newBatch = { hasDispatched: false, keys: [], callbacks: [] }
  loader._batch = newBatch

  // ì´ë²¤íŠ¸ ë£¨í”„ì˜ ë‹¤ìŒ í‹±ì— ë°°ì¹˜ ì²˜ë¦¬ ì˜ˆì•½
  loader._batchScheduleFn(() => {
    dispatchBatch(loader, newBatch)
  })

  return newBatch
}

// ë°°ì¹˜ ì‹¤í–‰ í•¨ìˆ˜
function dispatchBatch<K, V>(loader: DataLoader<K, V, any>, batch: Batch<K, V>) {
  // ë°°ì¹˜ ìƒíƒœ ì—…ë°ì´íŠ¸
  batch.hasDispatched = true

  // ë¹ˆ ë°°ì¹˜ëŠ” ë°”ë¡œ ì¢…ë£Œ
  if (batch.keys.length === 0) return

  // ì‚¬ìš©ì ì •ì˜ ë°°ì¹˜ í•¨ìˆ˜ í˜¸ì¶œ
  let batchPromise
  try {
    batchPromise = loader._batchLoadFn(batch.keys)
  } catch (e) {
    // ì—ëŸ¬ ì²˜ë¦¬...
  }

  // ê¸°íƒ€ ì—ëŸ¬ ì²˜ë¦¬...

  // ê²°ê³¼ ì²˜ë¦¬
  batchPromise
    .then((values) => {
      // ê° í‚¤ì— ëŒ€í•œ ê²°ê³¼ ë¶„ë°°
      for (let i = 0; i < batch.callbacks.length; i++) {
        const value = values[i]
        if (value instanceof Error) {
          batch.callbacks[i].reject(value)
        } else {
          batch.callbacks[i].resolve(value)
        }
      }
    })
    .catch((error) => {
      failedDispatch(loader, batch, error)
    })
}
```

<br />

`_batchScheduleFn`ì´ ì´í•´í•˜ê¸° ê¹Œë‹¤ë¡œì› ëŠ”ë° í•µì‹¬ ë¶€ë¶„ì´ë¼ê³  ìƒê°ëœë‹¤..! ğŸ§

<br />

`_batchScheduleFn`ì˜ í˜¸ì¶œ ì‹œì ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.

- `getCurrentBatch`ê°€ ìƒˆë¡œìš´ ë°°ì¹˜ë¥¼ ìƒì„±í•  ë•Œë§ˆë‹¤ í˜¸ì¶œ
- ë³´í†µ í•œ ì´ë²¤íŠ¸ ë£¨í”„ `tick` ë‚´ì—ì„œ ì²« ë²ˆì§¸ `load` í˜¸ì¶œ ì‹œì—ë§Œ ë°œìƒ
- ë°°ì¹˜ê°€ ì´ë¯¸ ì¡´ì¬í•˜ê³  ì¬ì‚¬ìš© ê°€ëŠ¥í•˜ë©´ í˜¸ì¶œë˜ì§€ ì•ŠìŒ

<br />

`dispatchBatch`ëŠ” ì•ì„œ `load` ë©”ì„œë“œì—ì„œ êµ¬ì„±í•œ `keys`, `callbacks`ì— ëŒ€í•œ ì²˜ë¦¬ê°€ ì´ë£¨ì–´ì§„ë‹¤ê³  ë³´ë©´ ë  ê²ƒ ê°™ë‹¤.

<br />

#### ë°°ì¹˜ ìŠ¤ì¼€ì¤„ë§ ë©”ì»¤ë‹ˆì¦˜

```ts
// ë°°ì¹˜ ìŠ¤ì¼€ì¤„ë§ í•¨ìˆ˜ ê²€ì¦
function getValidBatchScheduleFn(options): (() => void) => void {
  // ì˜µì…˜ì— ëª…ì‹œë˜ì§€ ì•Šì•˜ìœ¼ë©´ ê¸°ë³¸ê°’ ì‚¬ìš©
  if (!options || options.batchScheduleFn === undefined) {
    return enqueuePostPromiseJob;
  }
  return options.batchScheduleFn;
}

// í™˜ê²½ì— ë”°ë¥¸ ìŠ¤ì¼€ì¤„ë§ ì„ íƒ
const enqueuePostPromiseJob =
  // Node.js í™˜ê²½
  typeof process === 'object' && typeof process.nextTick === 'function'
    ? function(fn) {
        Promise.resolve().then(() => process.nextTick(fn));
      }
    // setImmediate ì§€ì› í™˜ê²½
    : typeof setImmediate === 'function'
    ? function(fn) {
        setImmediate(fn);
      }
    // ê¸°íƒ€ í™˜ê²½
    : function(fn) {
        setTimeout(fn);
      };
```

<br />

`getValidBatchScheduleFn`ì€ ì´ˆê¸°í™” ê³¼ì •ì—ì„œ `_batchScheduleFn`ì— ì‚¬ìš©ë˜ëŠ” í•¨ìˆ˜ì´ë‹¤.

(`_batchScheduleFn`ì€ `getCurrentBatch` í•¨ìˆ˜ ë‚´ë¶€ì—ì„œ ì‚¬ìš©ëœë‹¤.)

<br />

ì¼ë°˜ì ìœ¼ë¡œ `enqueuePostPromiseJob`ì„ ì‚¬ìš©í•˜ê²Œ ëœë‹¤.

ì—¬ê¸°ì—ì„œì˜ ë¹„ë™ê¸° ë™ì‘ìœ¼ë¡œ `load`ì—ì„œ ìˆ˜ì§‘í•œ ë™ì‘ì„ í•œ ë²ˆì— ì²˜ë¦¬í•  ìˆ˜ ìˆê²Œ í•´ì¤€ë‹¤.

<br />

**process.nextTick**

ì²˜ìŒ ì ‘í•œ ì½”ë“œì—¬ì„œ ì¶”ê°€ë¡œ ì •ë¦¬í•´ë³¸ë‹¤. ğŸ˜…

`Node.js` ì´ë²¤íŠ¸ ë£¨í”„ì—ì„œ ì œê³µí•˜ëŠ” ë¹„ë™ê¸° ì‹¤í–‰ ë©”ì»¤ë‹ˆì¦˜ì´ë‹¤.

<br />

`process.nextTick`ì— í•¨ìˆ˜ë¥¼ ì „ë‹¬í•˜ë©´ ì´ë²¤íŠ¸ ë£¨í”„ì—ì„œ í˜„ì¬ ì‹¤í–‰ ì½”ë“œê°€ ì™„ë£Œëœ ì§í›„,

ë‹¤ìŒ ë‹¨ê³„ë¡œ ì´ë™í•˜ê¸° ì „ì— í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•˜ë„ë¡ ì§€ì‹œí•œë‹¤.

<br />

> It's the way we can tell the JS engine to process a function asynchronously (after the current function),
> but as soon as possible,
> not queue it.

<br />

`JS` ì—”ì§„ì— í•¨ìˆ˜ë¥¼ ëŒ€ê¸°ì—´ì— ë„£ì§€ ì•Šê³  ê°€ëŠ¥í•œ ë¹ ë¥´ê²Œ ë¹„ë™ê¸°ì ìœ¼ë¡œ ì²˜ë¦¬í•  ìˆ˜ ìˆëŠ” ë°©ë²•ì´ë¼ê³  í•œë‹¤.

<br />

```js
setTimeout(() => {
  console.log('setTimeout ì½œë°±')
}, 0)

setImmediate(() => {
  console.log('setImmediate ì½œë°±')
})

process.nextTick(() => {
  console.log('nextTick ì½œë°±')
})

console.log('ë™ê¸° ì½”ë“œ')

// ë™ê¸° ì½”ë“œ
// nextTick ì½œë°±
// setImmediate ì½œë°±
// setTimeout ì½œë°±
```

## ì°¸ê³  ë¬¸ì„œ

- [GraphQL Why & How](https://mentoring.fromundefined.com/sessions/wi-241015)
- [dataloader](https://github.com/graphql/dataloader)
- [GraphQL N+1 Problem](https://www.youtube.com/watch?v=uCbFMZYQbxE)
- [Batching GraphQL Requests with DataLoader](https://www.youtube.com/watch?v=-uSDpEp5uJc)
- [Understanding process.nextTick()](https://nodejs.org/en/learn/asynchronous-work/understanding-processnexttick#understanding-processnexttick)
